/**
* @mdblog/code-plugin-orgchart v2.0.2
* Copyright Â© mdblog 2019.
*/

System.register(['@mdblog/mdblog', 'jquery', 'he', 'jsonic'], function (exports, module) {
  'use strict';
  var dynamicLoader, $, he, jsonic;
  return {
    setters: [function (module) {
      dynamicLoader = module.dynamicLoader;
    }, function (module) {
      $ = module.default;
    }, function (module) {
      he = module.default;
    }, function (module) {
      jsonic = module.default;
    }],
    execute: function () {

      dynamicLoader.register({
        test: 'orgchart',
        path: function path() {
          return "./node_modules/orgchart/dist/js/jquery.orgchart.min.js";
        }
      });

      //
      var script = {
        props: {
          metaTitle: {
            type: String,
            "default": ''
          },
          metaOpts: {
            type: String,
            "default": ''
          }
        },
        mounted: function mounted() {
          var _this = this;

          var mOrgchart = module.import('orgchart');
          mOrgchart.then(function () {
            var $el = $(_this.$refs.graph);

            try {
              var code = jsonic(he.decode($el.html()), false);
              $el.html('');
              $el.orgchart({
                data: code,
                depth: 2,
                nodeContent: 'desc'
              });
              $el.show();
            } catch (e) {
              $el.html(e);
              $el.show();
            }
          });
        }
      };

      function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
          if (typeof shadowMode !== 'boolean') {
              createInjectorSSR = createInjector;
              createInjector = shadowMode;
              shadowMode = false;
          }
          // Vue.extend constructor export interop.
          const options = typeof script === 'function' ? script.options : script;
          // render functions
          if (template && template.render) {
              options.render = template.render;
              options.staticRenderFns = template.staticRenderFns;
              options._compiled = true;
              // functional template
              if (isFunctionalTemplate) {
                  options.functional = true;
              }
          }
          // scopedId
          if (scopeId) {
              options._scopeId = scopeId;
          }
          let hook;
          if (moduleIdentifier) {
              // server build
              hook = function (context) {
                  // 2.3 injection
                  context =
                      context || // cached call
                          (this.$vnode && this.$vnode.ssrContext) || // stateful
                          (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
                  // 2.2 with runInNewContext: true
                  if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                      context = __VUE_SSR_CONTEXT__;
                  }
                  // inject component styles
                  if (style) {
                      style.call(this, createInjectorSSR(context));
                  }
                  // register component module identifier for async chunk inference
                  if (context && context._registeredComponents) {
                      context._registeredComponents.add(moduleIdentifier);
                  }
              };
              // used by ssr in case component is cached and beforeCreate
              // never gets called
              options._ssrRegister = hook;
          }
          else if (style) {
              hook = shadowMode
                  ? function (context) {
                      style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
                  }
                  : function (context) {
                      style.call(this, createInjector(context));
                  };
          }
          if (hook) {
              if (options.functional) {
                  // register for functional component in vue file
                  const originalRender = options.render;
                  options.render = function renderWithStyleInjection(h, context) {
                      hook.call(context);
                      return originalRender(h, context);
                  };
              }
              else {
                  // inject component registration as beforeCreate hook
                  const existing = options.beforeCreate;
                  options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
              }
          }
          return script;
      }

      const isOldIE = typeof navigator !== 'undefined' &&
          /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
      function createInjector(context) {
          return (id, style) => addStyle(id, style);
      }
      let HEAD;
      const styles = {};
      function addStyle(id, css) {
          const group = isOldIE ? css.media || 'default' : id;
          const style = styles[group] || (styles[group] = { ids: new Set(), styles: [] });
          if (!style.ids.has(id)) {
              style.ids.add(id);
              let code = css.source;
              if (css.map) {
                  // https://developer.chrome.com/devtools/docs/javascript-debugging
                  // this makes source maps inside style tags work properly in Chrome
                  code += '\n/*# sourceURL=' + css.map.sources[0] + ' */';
                  // http://stackoverflow.com/a/26603875
                  code +=
                      '\n/*# sourceMappingURL=data:application/json;base64,' +
                          btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
                          ' */';
              }
              if (!style.element) {
                  style.element = document.createElement('style');
                  style.element.type = 'text/css';
                  if (css.media)
                      style.element.setAttribute('media', css.media);
                  if (HEAD === undefined) {
                      HEAD = document.head || document.getElementsByTagName('head')[0];
                  }
                  HEAD.appendChild(style.element);
              }
              if ('styleSheet' in style.element) {
                  style.styles.push(code);
                  style.element.styleSheet.cssText = style.styles
                      .filter(Boolean)
                      .join('\n');
              }
              else {
                  const index = style.ids.size - 1;
                  const textNode = document.createTextNode(code);
                  const nodes = style.element.childNodes;
                  if (nodes[index])
                      style.element.removeChild(nodes[index]);
                  if (nodes.length)
                      style.element.insertBefore(textNode, nodes[index]);
                  else
                      style.element.appendChild(textNode);
              }
          }
      }

      /* script */
      var __vue_script__ = script;
      /* template */

      var __vue_render__ = function __vue_render__() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c("BTabs", {
          attrs: {
            small: "",
            card: ""
          }
        }, [_c("BTab", {
          attrs: {
            title: "Graph",
            active: ""
          }
        }, [_c("div", {
          ref: "graph"
        }, [_vm._t("default")], 2)]), _vm._v(" "), _c("BTab", {
          attrs: {
            title: "Source"
          }
        }, [_c("pre", [_vm._t("default")], 2)])], 1);
      };

      var __vue_staticRenderFns__ = [];
      __vue_render__._withStripped = true;
      /* style */

      var __vue_inject_styles__ = function __vue_inject_styles__(inject) {
        if (!inject) return;
        inject("data-v-9c265cd8_0", {
          source: "\n@import './node_modules/orgchart/dist/css/jquery.orgchart.min.css';\n",
          map: {
            "version": 3,
            "sources": ["/Users/vaniship/projects/u10-projects/mdblog-mono/mdblog/packages/code-plugin-orgchart/src/index.vue"],
            "names": [],
            "mappings": ";AAgDA,kEAAA",
            "file": "index.vue",
            "sourcesContent": ["<template>\n  <BTabs small card>\n    <BTab title=\"Graph\" active><div ref=\"graph\"><slot /></div></BTab>\n    <BTab title=\"Source\"><pre><slot /></pre></BTab>\n  </BTabs>\n\n</template>\n\n<script>\n  import './dynamic-dependencies'\n  import $ from 'jquery'\n  import he from 'he'\n  import jsonic from 'jsonic'\n\n  export default {\n    props: {\n      metaTitle: {\n        type: String,\n        default: ''\n      },\n      metaOpts: {\n        type: String,\n        default: ''\n      }\n    },\n    mounted () {\n      const mOrgchart = import('orgchart')\n      mOrgchart.then(() => {\n        var $el = $(this.$refs.graph)\n        try {\n          var code = jsonic(he.decode($el.html()), false)\n          $el.html('')\n          $el.orgchart({\n            data: code,\n            depth: 2,\n            nodeContent: 'desc'\n          })\n          $el.show()\n        } catch (e) {\n          $el.html(e)\n          $el.show()\n        }\n      })\n    }\n  }\n</script>\n\n<style scoped>\n  @import './node_modules/orgchart/dist/css/jquery.orgchart.min.css';\n</style>\n"]
          },
          media: undefined
        });
      };
      /* scoped */


      var __vue_scope_id__ = "data-v-9c265cd8";
      /* module identifier */

      var __vue_module_identifier__ = undefined;
      /* functional template */

      var __vue_is_functional_template__ = false;
      /* style inject SSR */

      /* style inject shadow dom */

      var __vue_component__ = exports('default', /*#__PURE__*/normalizeComponent({
        render: __vue_render__,
        staticRenderFns: __vue_staticRenderFns__
      }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, createInjector, undefined, undefined));

    }
  };
});
