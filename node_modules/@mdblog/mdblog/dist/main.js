/**
* @mdblog/mdblog v2.0.8
* Copyright © mdblog 2019.
*/

System.register(['vue', 'bootstrap-vue', 'axios', 'blueimp-md5', 'qs', 'marked', 'he', 'prismjs', 'prismjs/plugins/line-numbers/prism-line-numbers.min', 'prismjs/plugins/autoloader/prism-autoloader.min', 'prismjs/plugins/toolbar/prism-toolbar.min', 'prismjs/plugins/show-language/prism-show-language.min'], function (exports, module) {
  'use strict';
  var Vue$1, BootstrapVue, axios, md5, qs, marked, he, Prism;
  return {
    setters: [function (module) {
      Vue$1 = module.default;
    }, function (module) {
      BootstrapVue = module.default;
    }, function (module) {
      axios = module.default;
    }, function (module) {
      md5 = module.default;
    }, function (module) {
      qs = module.default;
    }, function (module) {
      marked = module.default;
    }, function (module) {
      he = module.default;
    }, function (module) {
      Prism = module.default;
    }, function () {}, function () {}, function () {}, function () {}],
    execute: function () {

      var resolveMap = [{
        test: /^@mdblog\/.*/,
        path: function path(id) {
          return "node_modules/".concat(id, "/dist/index.js");
        }
      }];
      var _resolve = System.resolve;

      System.resolve = function (id, parentURL) {
        if (!System.commonLibs[id]) {
          for (var _i = 0, _resolveMap = resolveMap; _i < _resolveMap.length; _i++) {
            var item = _resolveMap[_i];

            if (id.match(item.test)) {
              return item.path(id);
            }
          }
        }

        return _resolve.call(System, id, parentURL);
      };

      var dynamicLoader = exports('dynamicLoader', {
        load: function load(id) {
          return module.import(id);
        },
        register: function register(m) {
          resolveMap.push(m);
        }
      });

      function createCommonjsModule(fn, module) {
      	return module = { exports: {} }, fn(module, module.exports), module.exports;
      }

      var runtime_1 = createCommonjsModule(function (module) {
      /**
       * Copyright (c) 2014-present, Facebook, Inc.
       *
       * This source code is licensed under the MIT license found in the
       * LICENSE file in the root directory of this source tree.
       */

      var runtime = (function (exports$1) {

        var Op = Object.prototype;
        var hasOwn = Op.hasOwnProperty;
        var undefined$1; // More compressible than void 0.
        var $Symbol = typeof Symbol === "function" ? Symbol : {};
        var iteratorSymbol = $Symbol.iterator || "@@iterator";
        var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
        var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

        function wrap(innerFn, outerFn, self, tryLocsList) {
          // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
          var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
          var generator = Object.create(protoGenerator.prototype);
          var context = new Context(tryLocsList || []);

          // The ._invoke method unifies the implementations of the .next,
          // .throw, and .return methods.
          generator._invoke = makeInvokeMethod(innerFn, self, context);

          return generator;
        }
        exports$1.wrap = wrap;

        // Try/catch helper to minimize deoptimizations. Returns a completion
        // record like context.tryEntries[i].completion. This interface could
        // have been (and was previously) designed to take a closure to be
        // invoked without arguments, but in all the cases we care about we
        // already have an existing method we want to call, so there's no need
        // to create a new function object. We can even get away with assuming
        // the method takes exactly one argument, since that happens to be true
        // in every case, so we don't have to touch the arguments object. The
        // only additional allocation required is the completion record, which
        // has a stable shape and so hopefully should be cheap to allocate.
        function tryCatch(fn, obj, arg) {
          try {
            return { type: "normal", arg: fn.call(obj, arg) };
          } catch (err) {
            return { type: "throw", arg: err };
          }
        }

        var GenStateSuspendedStart = "suspendedStart";
        var GenStateSuspendedYield = "suspendedYield";
        var GenStateExecuting = "executing";
        var GenStateCompleted = "completed";

        // Returning this object from the innerFn has the same effect as
        // breaking out of the dispatch switch statement.
        var ContinueSentinel = {};

        // Dummy constructor functions that we use as the .constructor and
        // .constructor.prototype properties for functions that return Generator
        // objects. For full spec compliance, you may wish to configure your
        // minifier not to mangle the names of these two functions.
        function Generator() {}
        function GeneratorFunction() {}
        function GeneratorFunctionPrototype() {}

        // This is a polyfill for %IteratorPrototype% for environments that
        // don't natively support it.
        var IteratorPrototype = {};
        IteratorPrototype[iteratorSymbol] = function () {
          return this;
        };

        var getProto = Object.getPrototypeOf;
        var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
        if (NativeIteratorPrototype &&
            NativeIteratorPrototype !== Op &&
            hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
          // This environment has a native %IteratorPrototype%; use it instead
          // of the polyfill.
          IteratorPrototype = NativeIteratorPrototype;
        }

        var Gp = GeneratorFunctionPrototype.prototype =
          Generator.prototype = Object.create(IteratorPrototype);
        GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
        GeneratorFunctionPrototype.constructor = GeneratorFunction;
        GeneratorFunctionPrototype[toStringTagSymbol] =
          GeneratorFunction.displayName = "GeneratorFunction";

        // Helper for defining the .next, .throw, and .return methods of the
        // Iterator interface in terms of a single ._invoke method.
        function defineIteratorMethods(prototype) {
          ["next", "throw", "return"].forEach(function(method) {
            prototype[method] = function(arg) {
              return this._invoke(method, arg);
            };
          });
        }

        exports$1.isGeneratorFunction = function(genFun) {
          var ctor = typeof genFun === "function" && genFun.constructor;
          return ctor
            ? ctor === GeneratorFunction ||
              // For the native GeneratorFunction constructor, the best we can
              // do is to check its .name property.
              (ctor.displayName || ctor.name) === "GeneratorFunction"
            : false;
        };

        exports$1.mark = function(genFun) {
          if (Object.setPrototypeOf) {
            Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
          } else {
            genFun.__proto__ = GeneratorFunctionPrototype;
            if (!(toStringTagSymbol in genFun)) {
              genFun[toStringTagSymbol] = "GeneratorFunction";
            }
          }
          genFun.prototype = Object.create(Gp);
          return genFun;
        };

        // Within the body of any async function, `await x` is transformed to
        // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
        // `hasOwn.call(value, "__await")` to determine if the yielded value is
        // meant to be awaited.
        exports$1.awrap = function(arg) {
          return { __await: arg };
        };

        function AsyncIterator(generator) {
          function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if (record.type === "throw") {
              reject(record.arg);
            } else {
              var result = record.arg;
              var value = result.value;
              if (value &&
                  typeof value === "object" &&
                  hasOwn.call(value, "__await")) {
                return Promise.resolve(value.__await).then(function(value) {
                  invoke("next", value, resolve, reject);
                }, function(err) {
                  invoke("throw", err, resolve, reject);
                });
              }

              return Promise.resolve(value).then(function(unwrapped) {
                // When a yielded Promise is resolved, its final value becomes
                // the .value of the Promise<{value,done}> result for the
                // current iteration.
                result.value = unwrapped;
                resolve(result);
              }, function(error) {
                // If a rejected Promise was yielded, throw the rejection back
                // into the async generator function so it can be handled there.
                return invoke("throw", error, resolve, reject);
              });
            }
          }

          var previousPromise;

          function enqueue(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new Promise(function(resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }

            return previousPromise =
              // If enqueue has been called before, then we want to wait until
              // all previous Promises have been resolved before calling invoke,
              // so that results are always delivered in the correct order. If
              // enqueue has not been called before, then it is important to
              // call invoke immediately, without waiting on a callback to fire,
              // so that the async generator function has the opportunity to do
              // any necessary setup in a predictable way. This predictability
              // is why the Promise constructor synchronously invokes its
              // executor callback, and why async functions synchronously
              // execute code before the first await. Since we implement simple
              // async functions in terms of async generators, it is especially
              // important to get this right, even though it requires care.
              previousPromise ? previousPromise.then(
                callInvokeWithMethodAndArg,
                // Avoid propagating failures to Promises returned by later
                // invocations of the iterator.
                callInvokeWithMethodAndArg
              ) : callInvokeWithMethodAndArg();
          }

          // Define the unified helper method that is used to implement .next,
          // .throw, and .return (see defineIteratorMethods).
          this._invoke = enqueue;
        }

        defineIteratorMethods(AsyncIterator.prototype);
        AsyncIterator.prototype[asyncIteratorSymbol] = function () {
          return this;
        };
        exports$1.AsyncIterator = AsyncIterator;

        // Note that simple async functions are implemented on top of
        // AsyncIterator objects; they just return a Promise for the value of
        // the final result produced by the iterator.
        exports$1.async = function(innerFn, outerFn, self, tryLocsList) {
          var iter = new AsyncIterator(
            wrap(innerFn, outerFn, self, tryLocsList)
          );

          return exports$1.isGeneratorFunction(outerFn)
            ? iter // If outerFn is a generator, return the full iterator.
            : iter.next().then(function(result) {
                return result.done ? result.value : iter.next();
              });
        };

        function makeInvokeMethod(innerFn, self, context) {
          var state = GenStateSuspendedStart;

          return function invoke(method, arg) {
            if (state === GenStateExecuting) {
              throw new Error("Generator is already running");
            }

            if (state === GenStateCompleted) {
              if (method === "throw") {
                throw arg;
              }

              // Be forgiving, per 25.3.3.3.3 of the spec:
              // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
              return doneResult();
            }

            context.method = method;
            context.arg = arg;

            while (true) {
              var delegate = context.delegate;
              if (delegate) {
                var delegateResult = maybeInvokeDelegate(delegate, context);
                if (delegateResult) {
                  if (delegateResult === ContinueSentinel) continue;
                  return delegateResult;
                }
              }

              if (context.method === "next") {
                // Setting context._sent for legacy support of Babel's
                // function.sent implementation.
                context.sent = context._sent = context.arg;

              } else if (context.method === "throw") {
                if (state === GenStateSuspendedStart) {
                  state = GenStateCompleted;
                  throw context.arg;
                }

                context.dispatchException(context.arg);

              } else if (context.method === "return") {
                context.abrupt("return", context.arg);
              }

              state = GenStateExecuting;

              var record = tryCatch(innerFn, self, context);
              if (record.type === "normal") {
                // If an exception is thrown from innerFn, we leave state ===
                // GenStateExecuting and loop back for another invocation.
                state = context.done
                  ? GenStateCompleted
                  : GenStateSuspendedYield;

                if (record.arg === ContinueSentinel) {
                  continue;
                }

                return {
                  value: record.arg,
                  done: context.done
                };

              } else if (record.type === "throw") {
                state = GenStateCompleted;
                // Dispatch the exception by looping back around to the
                // context.dispatchException(context.arg) call above.
                context.method = "throw";
                context.arg = record.arg;
              }
            }
          };
        }

        // Call delegate.iterator[context.method](context.arg) and handle the
        // result, either by returning a { value, done } result from the
        // delegate iterator, or by modifying context.method and context.arg,
        // setting context.delegate to null, and returning the ContinueSentinel.
        function maybeInvokeDelegate(delegate, context) {
          var method = delegate.iterator[context.method];
          if (method === undefined$1) {
            // A .throw or .return when the delegate iterator has no .throw
            // method always terminates the yield* loop.
            context.delegate = null;

            if (context.method === "throw") {
              // Note: ["return"] must be used for ES3 parsing compatibility.
              if (delegate.iterator["return"]) {
                // If the delegate iterator has a return method, give it a
                // chance to clean up.
                context.method = "return";
                context.arg = undefined$1;
                maybeInvokeDelegate(delegate, context);

                if (context.method === "throw") {
                  // If maybeInvokeDelegate(context) changed context.method from
                  // "return" to "throw", let that override the TypeError below.
                  return ContinueSentinel;
                }
              }

              context.method = "throw";
              context.arg = new TypeError(
                "The iterator does not provide a 'throw' method");
            }

            return ContinueSentinel;
          }

          var record = tryCatch(method, delegate.iterator, context.arg);

          if (record.type === "throw") {
            context.method = "throw";
            context.arg = record.arg;
            context.delegate = null;
            return ContinueSentinel;
          }

          var info = record.arg;

          if (! info) {
            context.method = "throw";
            context.arg = new TypeError("iterator result is not an object");
            context.delegate = null;
            return ContinueSentinel;
          }

          if (info.done) {
            // Assign the result of the finished delegate to the temporary
            // variable specified by delegate.resultName (see delegateYield).
            context[delegate.resultName] = info.value;

            // Resume execution at the desired location (see delegateYield).
            context.next = delegate.nextLoc;

            // If context.method was "throw" but the delegate handled the
            // exception, let the outer generator proceed normally. If
            // context.method was "next", forget context.arg since it has been
            // "consumed" by the delegate iterator. If context.method was
            // "return", allow the original .return call to continue in the
            // outer generator.
            if (context.method !== "return") {
              context.method = "next";
              context.arg = undefined$1;
            }

          } else {
            // Re-yield the result returned by the delegate method.
            return info;
          }

          // The delegate iterator is finished, so forget it and continue with
          // the outer generator.
          context.delegate = null;
          return ContinueSentinel;
        }

        // Define Generator.prototype.{next,throw,return} in terms of the
        // unified ._invoke helper method.
        defineIteratorMethods(Gp);

        Gp[toStringTagSymbol] = "Generator";

        // A Generator should always return itself as the iterator object when the
        // @@iterator function is called on it. Some browsers' implementations of the
        // iterator prototype chain incorrectly implement this, causing the Generator
        // object to not be returned from this call. This ensures that doesn't happen.
        // See https://github.com/facebook/regenerator/issues/274 for more details.
        Gp[iteratorSymbol] = function() {
          return this;
        };

        Gp.toString = function() {
          return "[object Generator]";
        };

        function pushTryEntry(locs) {
          var entry = { tryLoc: locs[0] };

          if (1 in locs) {
            entry.catchLoc = locs[1];
          }

          if (2 in locs) {
            entry.finallyLoc = locs[2];
            entry.afterLoc = locs[3];
          }

          this.tryEntries.push(entry);
        }

        function resetTryEntry(entry) {
          var record = entry.completion || {};
          record.type = "normal";
          delete record.arg;
          entry.completion = record;
        }

        function Context(tryLocsList) {
          // The root entry object (effectively a try statement without a catch
          // or a finally block) gives us a place to store values thrown from
          // locations where there is no enclosing try statement.
          this.tryEntries = [{ tryLoc: "root" }];
          tryLocsList.forEach(pushTryEntry, this);
          this.reset(true);
        }

        exports$1.keys = function(object) {
          var keys = [];
          for (var key in object) {
            keys.push(key);
          }
          keys.reverse();

          // Rather than returning an object with a next method, we keep
          // things simple and return the next function itself.
          return function next() {
            while (keys.length) {
              var key = keys.pop();
              if (key in object) {
                next.value = key;
                next.done = false;
                return next;
              }
            }

            // To avoid creating an additional object, we just hang the .value
            // and .done properties off the next function object itself. This
            // also ensures that the minifier will not anonymize the function.
            next.done = true;
            return next;
          };
        };

        function values(iterable) {
          if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) {
              return iteratorMethod.call(iterable);
            }

            if (typeof iterable.next === "function") {
              return iterable;
            }

            if (!isNaN(iterable.length)) {
              var i = -1, next = function next() {
                while (++i < iterable.length) {
                  if (hasOwn.call(iterable, i)) {
                    next.value = iterable[i];
                    next.done = false;
                    return next;
                  }
                }

                next.value = undefined$1;
                next.done = true;

                return next;
              };

              return next.next = next;
            }
          }

          // Return an iterator with no values.
          return { next: doneResult };
        }
        exports$1.values = values;

        function doneResult() {
          return { value: undefined$1, done: true };
        }

        Context.prototype = {
          constructor: Context,

          reset: function(skipTempReset) {
            this.prev = 0;
            this.next = 0;
            // Resetting context._sent for legacy support of Babel's
            // function.sent implementation.
            this.sent = this._sent = undefined$1;
            this.done = false;
            this.delegate = null;

            this.method = "next";
            this.arg = undefined$1;

            this.tryEntries.forEach(resetTryEntry);

            if (!skipTempReset) {
              for (var name in this) {
                // Not sure about the optimal order of these conditions:
                if (name.charAt(0) === "t" &&
                    hasOwn.call(this, name) &&
                    !isNaN(+name.slice(1))) {
                  this[name] = undefined$1;
                }
              }
            }
          },

          stop: function() {
            this.done = true;

            var rootEntry = this.tryEntries[0];
            var rootRecord = rootEntry.completion;
            if (rootRecord.type === "throw") {
              throw rootRecord.arg;
            }

            return this.rval;
          },

          dispatchException: function(exception) {
            if (this.done) {
              throw exception;
            }

            var context = this;
            function handle(loc, caught) {
              record.type = "throw";
              record.arg = exception;
              context.next = loc;

              if (caught) {
                // If the dispatched exception was caught by a catch block,
                // then let that catch block handle the exception normally.
                context.method = "next";
                context.arg = undefined$1;
              }

              return !! caught;
            }

            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              var record = entry.completion;

              if (entry.tryLoc === "root") {
                // Exception thrown outside of any try block that could handle
                // it, so set the completion value of the entire function to
                // throw the exception.
                return handle("end");
              }

              if (entry.tryLoc <= this.prev) {
                var hasCatch = hasOwn.call(entry, "catchLoc");
                var hasFinally = hasOwn.call(entry, "finallyLoc");

                if (hasCatch && hasFinally) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  } else if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }

                } else if (hasCatch) {
                  if (this.prev < entry.catchLoc) {
                    return handle(entry.catchLoc, true);
                  }

                } else if (hasFinally) {
                  if (this.prev < entry.finallyLoc) {
                    return handle(entry.finallyLoc);
                  }

                } else {
                  throw new Error("try statement without catch or finally");
                }
              }
            }
          },

          abrupt: function(type, arg) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc <= this.prev &&
                  hasOwn.call(entry, "finallyLoc") &&
                  this.prev < entry.finallyLoc) {
                var finallyEntry = entry;
                break;
              }
            }

            if (finallyEntry &&
                (type === "break" ||
                 type === "continue") &&
                finallyEntry.tryLoc <= arg &&
                arg <= finallyEntry.finallyLoc) {
              // Ignore the finally entry if control is not jumping to a
              // location outside the try/catch block.
              finallyEntry = null;
            }

            var record = finallyEntry ? finallyEntry.completion : {};
            record.type = type;
            record.arg = arg;

            if (finallyEntry) {
              this.method = "next";
              this.next = finallyEntry.finallyLoc;
              return ContinueSentinel;
            }

            return this.complete(record);
          },

          complete: function(record, afterLoc) {
            if (record.type === "throw") {
              throw record.arg;
            }

            if (record.type === "break" ||
                record.type === "continue") {
              this.next = record.arg;
            } else if (record.type === "return") {
              this.rval = this.arg = record.arg;
              this.method = "return";
              this.next = "end";
            } else if (record.type === "normal" && afterLoc) {
              this.next = afterLoc;
            }

            return ContinueSentinel;
          },

          finish: function(finallyLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.finallyLoc === finallyLoc) {
                this.complete(entry.completion, entry.afterLoc);
                resetTryEntry(entry);
                return ContinueSentinel;
              }
            }
          },

          "catch": function(tryLoc) {
            for (var i = this.tryEntries.length - 1; i >= 0; --i) {
              var entry = this.tryEntries[i];
              if (entry.tryLoc === tryLoc) {
                var record = entry.completion;
                if (record.type === "throw") {
                  var thrown = record.arg;
                  resetTryEntry(entry);
                }
                return thrown;
              }
            }

            // The context.catch method must only be called with a location
            // argument that corresponds to a known catch block.
            throw new Error("illegal catch attempt");
          },

          delegateYield: function(iterable, resultName, nextLoc) {
            this.delegate = {
              iterator: values(iterable),
              resultName: resultName,
              nextLoc: nextLoc
            };

            if (this.method === "next") {
              // Deliberately forget the last sent value so that we don't
              // accidentally pass it on to the delegate.
              this.arg = undefined$1;
            }

            return ContinueSentinel;
          }
        };

        // Regardless of whether this script is executing as a CommonJS module
        // or not, return the runtime object so that we can declare the variable
        // regeneratorRuntime in the outer scope, which allows this module to be
        // injected easily by `bin/regenerator --include-runtime script.js`.
        return exports$1;

      }(
        // If this script is executing as a CommonJS module, use module.exports
        // as the regeneratorRuntime namespace. Otherwise create a new empty
        // object. Either way, the resulting object will be used to initialize
        // the regeneratorRuntime variable at the top of this file.
        module.exports
      ));

      try {
        regeneratorRuntime = runtime;
      } catch (accidentalStrictMode) {
        // This module should not be running in strict mode, so the above
        // assignment should always work unless something is misconfigured. Just
        // in case runtime.js accidentally runs in strict mode, we can escape
        // strict mode using a global Function call. This could conceivably fail
        // if a Content Security Policy forbids using Function, but in that case
        // the proper solution is to fix the accidental strict mode problem. If
        // you've misconfigured your bundler to force strict mode and applied a
        // CSP to forbid Function, and you're not willing to fix either of those
        // problems, please detail your unique predicament in a GitHub issue.
        Function("r", "regeneratorRuntime = r")(runtime);
      }
      });

      var regenerator = runtime_1;

      function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          Promise.resolve(value).then(_next, _throw);
        }
      }

      function _asyncToGenerator(fn) {
        return function () {
          var self = this,
              args = arguments;
          return new Promise(function (resolve, reject) {
            var gen = fn.apply(self, args);

            function _next(value) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }

            function _throw(err) {
              asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }

            _next(undefined);
          });
        };
      }

      var asyncToGenerator = _asyncToGenerator;

      function noop() {}
      /**
       * JSONP handler
       *
       * Options:
       *  - param {String} qs parameter (`callback`)
       *  - name {String} qs parameter
       *  - timeout {Number} how long after a timeout error is emitted (`60000`)
       *
       * @param {String} url
       * @param {Object|Function} optional options / callback
       * @param {Function} optional callback
       */


      var jsonp = (function (url, opts, fn) {
        if (typeof opts === 'function') {
          fn = opts;
          opts = {};
        }

        if (!opts) opts = {}; // use the callback name that was passed if one was provided.
        // otherwise generate a unique name by incrementing our counter.

        var id = opts.name;
        var param = opts.param || 'callback';
        var timeout = opts.timeout !== null ? opts.timeout : 60000;
        var enc = encodeURIComponent;
        var target = document.getElementsByTagName('script')[0] || document.head;
        var script;
        var timer;

        if (timeout) {
          timer = setTimeout(function () {
            cleanup();
            if (fn) fn(new Error('Timeout'));
          }, timeout);
        }

        function cleanup() {
          if (script.parentNode) script.parentNode.removeChild(script);
          window[id] = noop;
          if (timer) clearTimeout(timer);
        }

        function cancel() {
          if (window[id]) {
            cleanup();
          }
        }

        window[id] = function (data) {
          cleanup();
          if (fn) fn(null, data);
        }; // add qs component


        url += (~url.indexOf('?') ? '&' : '?') + param + '=' + enc(id);
        url = url.replace('?&', '?'); // create script

        script = document.createElement('script');
        script.src = url;
        target.parentNode.insertBefore(script, target);
        return cancel;
      });

      /* global location */
      var load = (function (url) {
        if (location.protocol === 'file:') {
          var hash = md5(url.replace(/^\.\//, ''));
          return new Promise(function (resolve, reject) {
            jsonp("mock/".concat(hash, ".js"), {
              name: 'jsonpcallback_' + hash
            }, function (err, data) {
              if (!err) {
                resolve({
                  data: data
                });
              } else {
                reject(err);
              }
            });
          });
        } else {
          return axios.get(url);
        }
      });

      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }

      var arrayWithHoles = _arrayWithHoles;

      function _iterableToArrayLimit(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = undefined;

        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);

            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }

        return _arr;
      }

      var iterableToArrayLimit = _iterableToArrayLimit;

      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }

      var nonIterableRest = _nonIterableRest;

      function _slicedToArray(arr, i) {
        return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
      }

      var slicedToArray = _slicedToArray;

      function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
          throw new TypeError("Cannot call a class as a function");
        }
      }

      var classCallCheck = _classCallCheck;

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }

      var createClass = _createClass;

      function normalizeArray(parts, allowAboveRoot) {
        var res = [];

        for (var i = 0; i < parts.length; i++) {
          var p = parts[i]; // ignore empty parts

          if (!p || p === '.') continue;

          if (p === '..') {
            if (res.length && res[res.length - 1] !== '..') {
              res.pop();
            } else if (allowAboveRoot) {
              res.push('..');
            }
          } else {
            res.push(p);
          }
        }

        return res;
      }

      function resolve() {
        var resolvedPath = '';
        var resolvedAbsolute = false;

        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = i >= 0 ? arguments[i] : '/'; // Skip empty and invalid entries

          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            continue;
          }

          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path[0] === '/';
        } // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        // Normalize the path


        resolvedPath = normalizeArray(resolvedPath.split('/'), !resolvedAbsolute).join('/');
        return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';
      }

      //
      //
      //
      //
      //
      //
      //
      //
      var script = {
        props: {
          metaPluginName: {
            type: String,
            "default": 'unknown'
          },
          metaTitle: {
            type: String,
            "default": ''
          },
          metaHref: {
            type: String,
            "default": ''
          },
          metaOpts: {
            type: String,
            "default": ''
          }
        }
      };

      function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
      /* server only */
      , shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
        if (typeof shadowMode !== 'boolean') {
          createInjectorSSR = createInjector;
          createInjector = shadowMode;
          shadowMode = false;
        } // Vue.extend constructor export interop.


        var options = typeof script === 'function' ? script.options : script; // render functions

        if (template && template.render) {
          options.render = template.render;
          options.staticRenderFns = template.staticRenderFns;
          options._compiled = true; // functional template

          if (isFunctionalTemplate) {
            options.functional = true;
          }
        } // scopedId


        if (scopeId) {
          options._scopeId = scopeId;
        }

        var hook;

        if (moduleIdentifier) {
          // server build
          hook = function hook(context) {
            // 2.3 injection
            context = context || // cached call
            this.$vnode && this.$vnode.ssrContext || // stateful
            this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
            // 2.2 with runInNewContext: true

            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
              context = __VUE_SSR_CONTEXT__;
            } // inject component styles


            if (style) {
              style.call(this, createInjectorSSR(context));
            } // register component module identifier for async chunk inference


            if (context && context._registeredComponents) {
              context._registeredComponents.add(moduleIdentifier);
            }
          }; // used by ssr in case component is cached and beforeCreate
          // never gets called


          options._ssrRegister = hook;
        } else if (style) {
          hook = shadowMode ? function () {
            style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
          } : function (context) {
            style.call(this, createInjector(context));
          };
        }

        if (hook) {
          if (options.functional) {
            // register for functional component in vue file
            var originalRender = options.render;

            options.render = function renderWithStyleInjection(h, context) {
              hook.call(context);
              return originalRender(h, context);
            };
          } else {
            // inject component registration as beforeCreate hook
            var existing = options.beforeCreate;
            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
          }
        }

        return script;
      }

      var normalizeComponent_1 = normalizeComponent;

      var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
      function createInjector(context) {
        return function (id, style) {
          return addStyle(id, style);
        };
      }
      var HEAD = document.head || document.getElementsByTagName('head')[0];
      var styles = {};

      function addStyle(id, css) {
        var group = isOldIE ? css.media || 'default' : id;
        var style = styles[group] || (styles[group] = {
          ids: new Set(),
          styles: []
        });

        if (!style.ids.has(id)) {
          style.ids.add(id);
          var code = css.source;

          if (css.map) {
            // https://developer.chrome.com/devtools/docs/javascript-debugging
            // this makes source maps inside style tags work properly in Chrome
            code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

            code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
          }

          if (!style.element) {
            style.element = document.createElement('style');
            style.element.type = 'text/css';
            if (css.media) style.element.setAttribute('media', css.media);
            HEAD.appendChild(style.element);
          }

          if ('styleSheet' in style.element) {
            style.styles.push(code);
            style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\n');
          } else {
            var index = style.ids.size - 1;
            var textNode = document.createTextNode(code);
            var nodes = style.element.childNodes;
            if (nodes[index]) style.element.removeChild(nodes[index]);
            if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
          }
        }
      }

      var browser = createInjector;

      /* script */
      var __vue_script__ = script;
      /* template */

      var __vue_render__ = function __vue_render__() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c("BTabs", {
          attrs: {
            small: "",
            card: ""
          }
        }, [_c("BTab", {
          attrs: {
            title: "Info",
            active: ""
          }
        }, [_vm._v("Link plugin load failed! [" + _vm._s(_vm.metaPluginName) + "]")]), _vm._v(" "), _c("BTab", {
          attrs: {
            title: "Code"
          }
        }, [_vm._v(_vm._s(_vm.metaTitle) + " " + _vm._s(_vm.metaHref) + " " + _vm._s(_vm.metaOpts))])], 1);
      };

      var __vue_staticRenderFns__ = [];
      __vue_render__._withStripped = true;
      /* style */

      var __vue_inject_styles__ = function __vue_inject_styles__(inject) {
        if (!inject) return;
        inject("data-v-42ec84d2_0", {
          source: "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
          map: {
            "version": 3,
            "sources": [],
            "names": [],
            "mappings": "",
            "file": "FailedLinkPlugin.vue"
          },
          media: undefined
        });
      };
      /* scoped */


      var __vue_scope_id__ = "data-v-42ec84d2";
      /* module identifier */

      var __vue_module_identifier__ = undefined;
      /* functional template */

      var __vue_is_functional_template__ = false;
      /* style inject SSR */

      var FailedLinkPlugin = normalizeComponent_1({
        render: __vue_render__,
        staticRenderFns: __vue_staticRenderFns__
      }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, browser, undefined);

      var getConfig = asyncToGenerator(
      /*#__PURE__*/
      regenerator.mark(function _callee() {
        var config, res;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                config = {};
                _context.prev = 1;
                _context.next = 4;
                return load('config.json');

              case 4:
                res = _context.sent;

                if (typeof res.data === 'string') {
                  res.data = JSON.parse(res.data);
                }

                Object.assign(config, res.data);
                console.log('Found a valid config.json file, using configuration', config);
                _context.next = 13;
                break;

              case 10:
                _context.prev = 10;
                _context.t0 = _context["catch"](1);
                console.error('unable to retrieve config.json: ' + _context.t0);

              case 13:
                return _context.abrupt("return", config);

              case 14:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, null, [[1, 10]]);
      }))();

      var _default =
      /*#__PURE__*/
      function () {
        function _default() {
          var _this = this;

          classCallCheck(this, _default);

          var dropdownTitle = '';
          var renderer = new marked.Renderer();

          renderer.paragraph = function (text) {
            return text;
          };

          renderer.image = function (href, title, text) {
            if (href === null) {
              return text;
            }

            var end = window.location.hash.lastIndexOf('/');
            var base;

            if (window.location.hash.startsWith('#!')) {
              base = window.location.hash.substring(2, end);
            } else {
              base = window.location.hash.substring(1, end);
            }

            var _qs$parse = qs.parse(href.split('?')[1]),
                width = _qs$parse.width,
                height = _qs$parse.height;

            if (!href.startsWith('/') && !/(http|https):\/\//.test(href)) {
              href = resolve(base, href);
            }

            return "<div style=\"text-align:center\"><img".concat(title ? " title=\"".concat(title, "\"") : '').concat(width ? " width=\"".concat(width, "\"") : '').concat(height ? " height=\"".concat(height, "\"") : '', " src=\"").concat(encodeURI("content".concat(href)), "\" alt=\"").concat(text, "\"/></div>");
          };

          renderer.list = function (body, ordered, start) {
            return "<BNavbarNav><BNavItemDropdown text=\"".concat(dropdownTitle, "\" >").concat(body, "</BNavItemDropdown></BNavbarNav>");
          };

          renderer.listitem = function (text) {
            return text.replace(/^(<)BNavbarNav><BNavItem|(<\/)BNavItem><\/BNavbarNav(>)$/g, '$1$2BDropdownItem$3');
          };

          renderer.link = function (href, title, text) {
            if (href) {
              var base;
              var end = window.location.hash.lastIndexOf('/');

              if (window.location.hash.startsWith('#!')) {
                base = window.location.hash.substring(2, end);
              } else {
                base = window.location.hash.substring(1, end);
              }

              if (/^plugin!.+/.test(text)) {
                // link 插件
                var _text$substr$split = text.substr(7).split(':'),
                    _text$substr$split2 = slicedToArray(_text$substr$split, 2),
                    url = _text$substr$split2[0],
                    _title = _text$substr$split2[1];

                var _url$split = url.split('?'),
                    _url$split2 = slicedToArray(_url$split, 2),
                    plugin = _url$split2[0],
                    query = _url$split2[1];

                plugin = "link-plugin-".concat(plugin);
                _this.components[plugin] =
                /*#__PURE__*/
                asyncToGenerator(
                /*#__PURE__*/
                regenerator.mark(function _callee() {
                  var component;
                  return regenerator.wrap(function _callee$(_context) {
                    while (1) {
                      switch (_context.prev = _context.next) {
                        case 0:
                          _context.prev = 0;
                          _context.next = 3;
                          return dynamicLoader.load("@mdblog/".concat(plugin));

                        case 3:
                          component = _context.sent;
                          _context.next = 9;
                          break;

                        case 6:
                          _context.prev = 6;
                          _context.t0 = _context["catch"](0);
                          component = FailedLinkPlugin;

                        case 9:
                          return _context.abrupt("return", component);

                        case 10:
                        case "end":
                          return _context.stop();
                      }
                    }
                  }, _callee, null, [[0, 6]]);
                }));
                return "<".concat(plugin, " meta-plugin-name=\"").concat(plugin, "\" meta-base-path=\"").concat(base, "\"").concat(_title ? " meta-title=\"".concat(_title, "\"") : '').concat(href ? " meta-href=\"".concat(href, "\"") : '').concat(query ? " meta-opts=\"".concat(query, "\"") : '', " />");
              } else {
                if (!href.startsWith('/') && !/(http|https):\/\//.test(href)) {
                  href = resolve(base, href);
                }

                if (href.startsWith('/')) href = "#!".concat(href);
                return "<BNavbarNav><BNavItem href=\"".concat(href, "\">").concat(text, "</BNavItem></BNavbarNav>");
              }
            } else {
              dropdownTitle = text;
              return '';
            }
          };

          this.options = {
            renderer: renderer,
            breaks: true
          };
        }

        createClass(_default, [{
          key: "parse",
          value: function () {
            var _parse = asyncToGenerator(
            /*#__PURE__*/
            regenerator.mark(function _callee2(md) {
              var appTitle, config, uglyHtml;
              return regenerator.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      this.components = {};
                      appTitle = 'MDBlog';
                      _context2.prev = 2;
                      _context2.next = 5;
                      return getConfig;

                    case 5:
                      config = _context2.sent;
                      appTitle = config.title;
                      _context2.next = 11;
                      break;

                    case 9:
                      _context2.prev = 9;
                      _context2.t0 = _context2["catch"](2);

                    case 11:
                      uglyHtml = marked(md, this.options);
                      return _context2.abrupt("return", "<BNavbar id=\"mdblog-navigation\" toggleable=\"md\" type=\"light\" variant=\"light\"><BNavbarBrand href=\"#!/index.md\">".concat(appTitle, "</BNavbarBrand><BNavbarToggle target=\"nav-collapse\"></BNavbarToggle><BCollapse id=\"nav-collapse\" is-nav>").concat(uglyHtml, "</BCollapse></BNavbar>"));

                    case 13:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2, this, [[2, 9]]);
            }));

            function parse(_x) {
              return _parse.apply(this, arguments);
            }

            return parse;
          }()
        }, {
          key: "getComponents",
          value: function getComponents() {
            return this.components;
          }
        }]);

        return _default;
      }();

      var markdown = new _default();
      var script$1 = {
        render: function render(h) {
          var c = Vue.compile(this.content);
          c.components = markdown.getComponents();
          return h(c);
        },
        data: function data() {
          return {
            content: ''
          };
        },
        mounted: function () {
          var _mounted = asyncToGenerator(
          /*#__PURE__*/
          regenerator.mark(function _callee() {
            var href, res;
            return regenerator.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    href = 'navigation.md';
                    _context.prev = 1;
                    _context.next = 4;
                    return load("./content/".concat(href));

                  case 4:
                    res = _context.sent;
                    _context.next = 7;
                    return markdown.parse(res.data);

                  case 7:
                    this.content = _context.sent;
                    _context.next = 15;
                    break;

                  case 10:
                    _context.prev = 10;
                    _context.t0 = _context["catch"](1);
                    _context.next = 14;
                    return markdown.parse("# Load content failed [".concat(href, "]: ").concat(_context.t0.message));

                  case 14:
                    this.content = _context.sent;

                  case 15:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this, [[1, 10]]);
          }));

          function mounted() {
            return _mounted.apply(this, arguments);
          }

          return mounted;
        }()
      };

      /* script */
      var __vue_script__$1 = script$1;
      /* template */

      /* style */

      var __vue_inject_styles__$1 = function __vue_inject_styles__(inject) {
        if (!inject) return;
        inject("data-v-d9daf7fc_0", {
          source: "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
          map: {
            "version": 3,
            "sources": [],
            "names": [],
            "mappings": "",
            "file": "Navigation.vue"
          },
          media: undefined
        });
      };
      /* scoped */


      var __vue_scope_id__$1 = "data-v-d9daf7fc";
      /* module identifier */

      var __vue_module_identifier__$1 = undefined;
      /* functional template */

      var __vue_is_functional_template__$1 = undefined;
      /* style inject SSR */

      var Navigation = exports('Navigation', normalizeComponent_1({}, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, browser, undefined));

      var _typeof_1 = createCommonjsModule(function (module) {
      function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

      function _typeof(obj) {
        if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
          module.exports = _typeof = function _typeof(obj) {
            return _typeof2(obj);
          };
        } else {
          module.exports = _typeof = function _typeof(obj) {
            return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
          };
        }

        return _typeof(obj);
      }

      module.exports = _typeof;
      });

      function _assertThisInitialized(self) {
        if (self === void 0) {
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return self;
      }

      var assertThisInitialized = _assertThisInitialized;

      function _possibleConstructorReturn(self, call) {
        if (call && (_typeof_1(call) === "object" || typeof call === "function")) {
          return call;
        }

        return assertThisInitialized(self);
      }

      var possibleConstructorReturn = _possibleConstructorReturn;

      var getPrototypeOf = createCommonjsModule(function (module) {
      function _getPrototypeOf(o) {
        module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
          return o.__proto__ || Object.getPrototypeOf(o);
        };
        return _getPrototypeOf(o);
      }

      module.exports = _getPrototypeOf;
      });

      var setPrototypeOf = createCommonjsModule(function (module) {
      function _setPrototypeOf(o, p) {
        module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
          o.__proto__ = p;
          return o;
        };

        return _setPrototypeOf(o, p);
      }

      module.exports = _setPrototypeOf;
      });

      function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
          throw new TypeError("Super expression must either be null or a function");
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        });
        if (superClass) setPrototypeOf(subClass, superClass);
      }

      var inherits = _inherits;

      //
      //
      //
      //
      //
      //
      //
      //
      var script$2 = {
        props: {
          metaPluginName: {
            type: String,
            "default": 'unknown'
          },
          metaTitle: {
            type: String,
            "default": ''
          },
          metaOpts: {
            type: String,
            "default": ''
          }
        }
      };

      /* script */
      var __vue_script__$2 = script$2;
      /* template */

      var __vue_render__$1 = function __vue_render__() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c("BTabs", {
          attrs: {
            small: "",
            card: ""
          }
        }, [_c("BTab", {
          attrs: {
            title: "Info",
            active: ""
          }
        }, [_vm._v("Code plugin load failed! [" + _vm._s(_vm.metaPluginName) + "]")]), _vm._v(" "), _c("BTab", {
          attrs: {
            title: "Code"
          }
        }, [_c("pre", [_vm._t("default")], 2)])], 1);
      };

      var __vue_staticRenderFns__$1 = [];
      __vue_render__$1._withStripped = true;
      /* style */

      var __vue_inject_styles__$2 = function __vue_inject_styles__(inject) {
        if (!inject) return;
        inject("data-v-ed2d581c_0", {
          source: "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
          map: {
            "version": 3,
            "sources": [],
            "names": [],
            "mappings": "",
            "file": "FailedCodePlugin.vue"
          },
          media: undefined
        });
      };
      /* scoped */


      var __vue_scope_id__$2 = "data-v-ed2d581c";
      /* module identifier */

      var __vue_module_identifier__$2 = undefined;
      /* functional template */

      var __vue_is_functional_template__$2 = false;
      /* style inject SSR */

      var FailedCodePlugin = normalizeComponent_1({
        render: __vue_render__$1,
        staticRenderFns: __vue_staticRenderFns__$1
      }, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, browser, undefined);

      var _default$1 =
      /*#__PURE__*/
      function (_Vue) {
        inherits(_default, _Vue);

        function _default() {
          var _this;

          classCallCheck(this, _default);

          _this = possibleConstructorReturn(this, getPrototypeOf(_default).call(this));
          Prism.plugins.autoloader.languages_path = 'node_modules/prismjs/components/';
          var renderer = new marked.Renderer();

          renderer.heading = function (text, level) {
            return "<h".concat(level, " id=\"_").concat(md5(text), "\">").concat(text, "</h").concat(level, ">");
          };

          renderer.table = function (header, body) {
            if (body) body = '<tbody>' + body + '</tbody>';
            return "<table class=\"table-bordered\">\n<thead>\n".concat(header, "</thead>\n").concat(body, "</table>\n");
          };

          renderer.image = function (href, title, text) {
            if (href === null) {
              return text;
            }

            var end = window.location.hash.lastIndexOf('/');
            var base;

            if (window.location.hash.startsWith('#!')) {
              base = window.location.hash.substring(2, end);
            } else {
              base = window.location.hash.substring(1, end);
            }

            var _qs$parse = qs.parse(href.split('?')[1]),
                width = _qs$parse.width,
                height = _qs$parse.height;

            if (!href.startsWith('/') && !/(http|https):\/\//.test(href)) {
              href = resolve(base, href);
            }

            return "<div style=\"text-align:center\"><img".concat(title ? " title=\"".concat(title, "\"") : '').concat(width ? " width=\"".concat(width, "\"") : '').concat(height ? " height=\"".concat(height, "\"") : '', " src=\"").concat(encodeURI("content".concat(href)), "\" alt=\"").concat(text, "\"/></div>");
          };

          var _link = renderer.link;

          renderer.link = function (href, title, text) {
            var base;
            var end = window.location.hash.lastIndexOf('/');

            if (window.location.hash.startsWith('#!')) {
              base = window.location.hash.substring(2, end);
            } else {
              base = window.location.hash.substring(1, end);
            }

            if (/^plugin!.+/.test(text)) {
              // link 插件
              var _text$substr$split = text.substr(7).split(':'),
                  _text$substr$split2 = slicedToArray(_text$substr$split, 2),
                  url = _text$substr$split2[0],
                  _title = _text$substr$split2[1];

              var _url$split = url.split('?'),
                  _url$split2 = slicedToArray(_url$split, 2),
                  plugin = _url$split2[0],
                  query = _url$split2[1];

              plugin = "link-plugin-".concat(plugin);
              _this.components[plugin] =
              /*#__PURE__*/
              asyncToGenerator(
              /*#__PURE__*/
              regenerator.mark(function _callee() {
                var component;
                return regenerator.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        _context.prev = 0;
                        _context.next = 3;
                        return dynamicLoader.load("@mdblog/".concat(plugin));

                      case 3:
                        component = _context.sent;
                        _context.next = 9;
                        break;

                      case 6:
                        _context.prev = 6;
                        _context.t0 = _context["catch"](0);
                        component = FailedLinkPlugin;

                      case 9:
                        return _context.abrupt("return", component);

                      case 10:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee, null, [[0, 6]]);
              }));
              return "<".concat(plugin, " meta-plugin-name=\"").concat(plugin, "\" meta-base-path=\"").concat(base, "\"").concat(_title ? " meta-title=\"".concat(_title, "\"") : '').concat(href ? " meta-href=\"".concat(href, "\"") : '').concat(query ? " meta-opts=\"".concat(query, "\"") : '', " />");
            } else {
              if (!href.startsWith('/') && !/(http|https):\/\//.test(href)) {
                href = resolve(base, href);
              }

              if (href.startsWith('/')) href = "#!".concat(href);
              return _link.call(renderer, href, title, text);
            }
          };

          var _code = renderer.code;

          renderer.code = function (code, lang) {
            var matches = lang.match(/^(?:\s*([a-zA-Z0-9-_]+)\s+|)(plugin!.+)$/);

            if (matches) {
              // link 插件
              var _matches$2$substr$spl = matches[2].substr(7).split(':'),
                  _matches$2$substr$spl2 = slicedToArray(_matches$2$substr$spl, 2),
                  url = _matches$2$substr$spl2[0],
                  title = _matches$2$substr$spl2[1];

              var _url$split3 = url.split('?'),
                  _url$split4 = slicedToArray(_url$split3, 2),
                  plugin = _url$split4[0],
                  query = _url$split4[1];

              plugin = "code-plugin-".concat(plugin);
              _this.components[plugin] =
              /*#__PURE__*/
              asyncToGenerator(
              /*#__PURE__*/
              regenerator.mark(function _callee2() {
                var component;
                return regenerator.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.prev = 0;
                        _context2.next = 3;
                        return dynamicLoader.load("@mdblog/".concat(plugin));

                      case 3:
                        component = _context2.sent;
                        _context2.next = 10;
                        break;

                      case 6:
                        _context2.prev = 6;
                        _context2.t0 = _context2["catch"](0);
                        console.error('e');
                        component = FailedCodePlugin;

                      case 10:
                        return _context2.abrupt("return", component);

                      case 11:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2, null, [[0, 6]]);
              }));
              return "<".concat(plugin, " meta-plugin-name=\"").concat(plugin, "\"").concat(title ? " meta-title=\"".concat(title, "\"") : '').concat(query ? " meta-opts=\"".concat(query, "\"") : '', ">").concat(he.encode(code), "</").concat(plugin, ">");
            } else {
              return _code.call(renderer, code, lang);
            }
          };

          _this.options = {
            renderer: renderer,
            gfm: true,
            tables: true,
            breaks: true,
            langPrefix: 'line-numbers lang-',
            highlight: function highlight(code, lang) {
              var type = Prism.languages[lang];

              if (!type) {
                type = Prism.languages.clike;
              }

              return Prism.highlight(code, type);
            }
          };

          _this.$on('mounted',
          /*#__PURE__*/
          asyncToGenerator(
          /*#__PURE__*/
          regenerator.mark(function _callee3() {
            return regenerator.wrap(function _callee3$(_context3) {
              while (1) {
                switch (_context3.prev = _context3.next) {
                  case 0:
                    Prism.highlightAll();

                  case 1:
                  case "end":
                    return _context3.stop();
                }
              }
            }, _callee3);
          })));

          return _this;
        }

        createClass(_default, [{
          key: "parse",
          value: function () {
            var _parse = asyncToGenerator(
            /*#__PURE__*/
            regenerator.mark(function _callee4(md) {
              var uglyHtml;
              return regenerator.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:
                      this.components = {};
                      uglyHtml = marked(md, this.options);
                      return _context4.abrupt("return", "<div id=\"mdblog-content\" style=\"position:relative; overflow-y:auto\">".concat(uglyHtml, "</div>"));

                    case 3:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4, this);
            }));

            function parse(_x) {
              return _parse.apply(this, arguments);
            }

            return parse;
          }()
        }, {
          key: "getComponents",
          value: function getComponents() {
            return this.components;
          }
        }]);

        return _default;
      }(Vue$1);

      function easeInOutQuad(t, b, c, d) {
        t /= d / 2;
        if (t < 1) return c / 2 * t * t + b;
        t--;
        return -c / 2 * (t * (t - 2) - 1) + b;
      }

      function scrollTo(scroller, to, duration, cb) {
        var start = scroller.scrollTop;
        var change = to - start;
        var increment = 20;
        var currentTime = 0;

        var animateScroll = function animateScroll() {
          currentTime += increment;
          var val = easeInOutQuad(currentTime, start, change, duration);
          scroller.scrollTop = Math.round(val);

          if (currentTime < duration) {
            setTimeout(animateScroll, increment);
          } else if (cb && typeof cb === 'function') {
            cb();
          }
        };

        animateScroll();
      }
      function offsetTop(el) {
        if (!el.getClientRects().length) {
          return 0;
        }

        var bcr = el.getBoundingClientRect();
        var win = el.ownerDocument.defaultView;
        return bcr.top + win.pageYOffset;
      }
      function appendDefaultFilenameToHash() {
        var newHashString = '';
        var currentHashString = window.location.hash || '';

        if (currentHashString === '' || currentHashString === '#' || currentHashString === '#!') {
          newHashString = '#!index.md';
        } else if (currentHashString.startsWith('#!') && currentHashString.endsWith('/')) {
          newHashString = currentHashString + 'index.md';
        }

        if (newHashString) {
          window.location.hash = newHashString;
        }
      }

      var markdown$1 = new _default$1();
      var script$3 = {
        created: function created() {
          var _this = this;

          window.onhashchange = function () {
            _this.loadContent();
          };

          this.$root.$on('content-scroll-to-id', function (id) {
            var $el = document.body.querySelector("[id='".concat(id, "']"));

            if ($el) {
              // Get the document scrolling element
              var scroller = document.scrollingElement || document.documentElement || document.body; // Scroll heading into view (minus offset to account for nav top height

              var $ref = _this.$el;

              while ($ref && $ref.offsetTop === 0) {
                $ref = $ref.offsetParent;
              }

              var top = $ref && $ref.offsetTop || 0;
              scrollTo(scroller, offsetTop($el) - top, 100, function () {
                // Set a tab index so we can focus header for a11y support
                $el.tabIndex = -1; // Focus the heading

                $el.focus();
              });
            }
          });
        },
        data: function data() {
          return {
            content: ''
          };
        },
        mounted: function mounted() {
          this.loadContent();
        },
        methods: {
          loadContent: function () {
            var _loadContent = asyncToGenerator(
            /*#__PURE__*/
            regenerator.mark(function _callee() {
              var href, _ref, md;

              return regenerator.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      if (window.location.hash.startsWith('#!')) {
                        href = window.location.hash.substring(2);
                      } else {
                        href = window.location.hash.substring(1);
                      }

                      href = decodeURIComponent(href);
                      href = href.replace(/^\//, '');

                      if (!href) {
                        _context.next = 21;
                        break;
                      }

                      _context.prev = 4;
                      _context.next = 7;
                      return load("./content/".concat(href));

                    case 7:
                      _ref = _context.sent;
                      md = _ref.data;
                      this.$root.$emit('content-change', md);
                      _context.next = 12;
                      return markdown$1.parse(md);

                    case 12:
                      this.content = _context.sent;
                      this.$nextTick(function () {
                        markdown$1.$emit('mounted');
                      });
                      _context.next = 21;
                      break;

                    case 16:
                      _context.prev = 16;
                      _context.t0 = _context["catch"](4);
                      _context.next = 20;
                      return markdown$1.parse("# Load content failed [".concat(href, "]: ").concat(_context.t0.message));

                    case 20:
                      this.content = _context.sent;

                    case 21:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, this, [[4, 16]]);
            }));

            function loadContent() {
              return _loadContent.apply(this, arguments);
            }

            return loadContent;
          }()
        },
        render: function render(h) {
          if (!this.content) return '';
          var content = Vue.compile(this.content);
          content.components = markdown$1.getComponents();
          return h(content);
        }
      };

      /* script */
      var __vue_script__$3 = script$3;
      /* template */

      /* style */

      var __vue_inject_styles__$3 = function __vue_inject_styles__(inject) {
        if (!inject) return;
        inject("data-v-2e7ecc36_0", {
          source: "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
          map: {
            "version": 3,
            "sources": [],
            "names": [],
            "mappings": "",
            "file": "Content.vue"
          },
          media: undefined
        });
      };
      /* scoped */


      var __vue_scope_id__$3 = "data-v-2e7ecc36";
      /* module identifier */

      var __vue_module_identifier__$3 = undefined;
      /* functional template */

      var __vue_is_functional_template__$3 = undefined;
      /* style inject SSR */

      var Content = exports('Content', normalizeComponent_1({}, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, browser, undefined));

      var renderer = new marked.Renderer();

      var fun = function fun() {
        return '';
      };

      for (var _i = 0, _Object$keys = Object.keys(marked.Renderer.prototype); _i < _Object$keys.length; _i++) {
        var m = _Object$keys[_i];
        if (m !== 'text') renderer[m] = fun;
      }

      renderer.heading = function (text, level) {
        if (level > 1 && level < 3) {
          var hash = md5(text);
          return "<BNavItem href=\"#_".concat(hash, "\" @click=\"contentScrollToId($event, '_").concat(hash, "')\">").concat(text, "</BNavItem>");
        }

        return '';
      };

      var options = {
        renderer: renderer,
        breaks: true
      };
      var script$4 = {
        render: function render(h) {
          var toc = Vue.compile(this.toc);
          toc.methods = this.$options.methods;
          return h(toc);
        },
        props: {
          content: {
            type: String,
            "default": ''
          }
        },
        data: function data() {
          return {
            toc: ''
          };
        },
        mounted: function mounted() {
          var _this = this;

          this.$root.$on('content-change', function (md) {
            var $el = document.body.querySelector("[id=mdblog-content]");
            var $ref = _this.$el;

            while ($ref && $ref.offsetTop === 0) {
              $ref = $ref.offsetParent;
            }

            var top = $ref && $ref.offsetTop || 0;
            _this.toc = "<BNav id=\"mdblog-toc\" vertical small v-b-scrollspy=\"".concat(top, "\">").concat(marked(md, options), "</BNav>");
          });
        },
        methods: {
          contentScrollToId: function contentScrollToId(evt, id) {
            evt.preventDefault();
            this.$root.$emit('content-scroll-to-id', id);
          }
        }
      };

      /* script */
      var __vue_script__$4 = script$4;
      /* template */

      /* style */

      var __vue_inject_styles__$4 = function __vue_inject_styles__(inject) {
        if (!inject) return;
        inject("data-v-1216063a_0", {
          source: "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
          map: {
            "version": 3,
            "sources": [],
            "names": [],
            "mappings": "",
            "file": "Toc.vue"
          },
          media: undefined
        });
      };
      /* scoped */


      var __vue_scope_id__$4 = undefined;
      /* module identifier */

      var __vue_module_identifier__$4 = undefined;
      /* functional template */

      var __vue_is_functional_template__$4 = undefined;
      /* style inject SSR */

      var Toc = exports('Toc', normalizeComponent_1({}, __vue_inject_styles__$4, __vue_script__$4, __vue_scope_id__$4, __vue_is_functional_template__$4, __vue_module_identifier__$4, browser, undefined));

      var script$5 = {
        components: {
          Theme: function () {
            var _Theme = asyncToGenerator(
            /*#__PURE__*/
            regenerator.mark(function _callee() {
              var config, themeName, component;
              return regenerator.wrap(function _callee$(_context) {
                while (1) {
                  switch (_context.prev = _context.next) {
                    case 0:
                      _context.next = 2;
                      return getConfig;

                    case 2:
                      config = _context.sent;
                      themeName = config.theme || 'default';
                      _context.prev = 4;
                      _context.next = 7;
                      return dynamicLoader.load("@mdblog/theme-".concat(themeName));

                    case 7:
                      component = _context.sent;
                      _context.next = 16;
                      break;

                    case 10:
                      _context.prev = 10;
                      _context.t0 = _context["catch"](4);
                      console.log("Load theme failed [".concat(themeName, "], use default."));
                      _context.next = 15;
                      return dynamicLoader.load("@mdblog/theme-default");

                    case 15:
                      component = _context.sent;

                    case 16:
                      return _context.abrupt("return", component);

                    case 17:
                    case "end":
                      return _context.stop();
                  }
                }
              }, _callee, null, [[4, 10]]);
            }));

            function Theme() {
              return _Theme.apply(this, arguments);
            }

            return Theme;
          }()
        }
      };

      /* script */
      var __vue_script__$5 = script$5;
      /* template */

      var __vue_render__$2 = function __vue_render__() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c("div", {
          attrs: {
            id: "app"
          }
        }, [_c("Theme", {
          attrs: {
            id: "md-all"
          }
        })], 1);
      };

      var __vue_staticRenderFns__$2 = [];
      __vue_render__$2._withStripped = true;
      /* style */

      var __vue_inject_styles__$5 = function __vue_inject_styles__(inject) {
        if (!inject) return;
        inject("data-v-5666e98f_0", {
          source: "\n@import './node_modules/font-awesome/css/font-awesome.min.css';\n@import './node_modules/bootstrap/dist/css/bootstrap.css';\n@import './node_modules/bootstrap-vue/dist/bootstrap-vue.css';\n@import './node_modules/prismjs/themes/prism-dark.css';\n@import './node_modules/prismjs/plugins/toolbar/prism-toolbar.css';\n@import './node_modules/prismjs/plugins/line-numbers/prism-line-numbers.css';\n@import './node_modules/@mdblog/mdblog/dist/style/index.css';\n",
          map: {
            "version": 3,
            "sources": ["/Users/vaniship/projects/javascript/mdblog-workspace/packages/@mdblog/mdblog/src/App.vue"],
            "names": [],
            "mappings": ";AA8BA,8DAAA;AACA,yDAAA;AACA,6DAAA;AACA,sDAAA;AACA,kEAAA;AACA,4EAAA;AACA,4DAAA",
            "file": "App.vue",
            "sourcesContent": ["\n<template>\n  <div id=\"app\">\n    <Theme id=\"md-all\"/>\n  </div>\n</template>\n\n<script>\n  import dynamicLoader from './lib/dynamic-loader'\n  import getConfig from './lib/config'\n\n  export default {\n    components: {\n      async Theme () {\n        const config = await getConfig\n        const themeName = config.theme || 'default'\n        let component\n        try {\n          component = await dynamicLoader.load(`@mdblog/theme-${themeName}`)\n        } catch (e) {\n          console.log(`Load theme failed [${themeName}], use default.`)\n          component = await dynamicLoader.load(`@mdblog/theme-default`)\n        }\n        return component\n      }\n    },\n  }\n</script>\n\n<style>\n  @import './node_modules/font-awesome/css/font-awesome.min.css';\n  @import './node_modules/bootstrap/dist/css/bootstrap.css';\n  @import './node_modules/bootstrap-vue/dist/bootstrap-vue.css';\n  @import './node_modules/prismjs/themes/prism-dark.css';\n  @import './node_modules/prismjs/plugins/toolbar/prism-toolbar.css';\n  @import './node_modules/prismjs/plugins/line-numbers/prism-line-numbers.css';\n  @import './node_modules/@mdblog/mdblog/dist/style/index.css';\n</style>\n"]
          },
          media: undefined
        });
      };
      /* scoped */


      var __vue_scope_id__$5 = undefined;
      /* module identifier */

      var __vue_module_identifier__$5 = undefined;
      /* functional template */

      var __vue_is_functional_template__$5 = false;
      /* style inject SSR */

      var App = normalizeComponent_1({
        render: __vue_render__$2,
        staticRenderFns: __vue_staticRenderFns__$2
      }, __vue_inject_styles__$5, __vue_script__$5, __vue_scope_id__$5, __vue_is_functional_template__$5, __vue_module_identifier__$5, browser, undefined);

      appendDefaultFilenameToHash();
      Vue$1.use(BootstrapVue);
      var vue = new Vue$1({
        $bus: new Vue$1(),
        render: function render(h) {
          return h(App);
        }
      });
      vue.$mount('#app');

    }
  };
});
