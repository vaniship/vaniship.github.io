/**
* @mdblog/code-plugin-mindmap v2.0.3
* Copyright Â© mdblog 2019.
*/

System.register(['@mdblog/mdblog', 'he', 'jsonic', 'qs'], function (exports, module) {
  'use strict';
  var dynamicLoader, he, jsonic, qs;
  return {
    setters: [function (module) {
      dynamicLoader = module.dynamicLoader;
    }, function (module) {
      he = module.default;
    }, function (module) {
      jsonic = module.default;
    }, function (module) {
      qs = module.default;
    }],
    execute: function () {

      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }

      var arrayWithHoles = _arrayWithHoles;

      function _iterableToArrayLimit(arr, i) {
        if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = undefined;

        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);

            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }

        return _arr;
      }

      var iterableToArrayLimit = _iterableToArrayLimit;

      function _arrayLikeToArray(arr, len) {
        if (len == null || len > arr.length) len = arr.length;

        for (var i = 0, arr2 = new Array(len); i < len; i++) {
          arr2[i] = arr[i];
        }

        return arr2;
      }

      var arrayLikeToArray = _arrayLikeToArray;

      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if (typeof o === "string") return arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        if (n === "Object" && o.constructor) n = o.constructor.name;
        if (n === "Map" || n === "Set") return Array.from(o);
        if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
      }

      var unsupportedIterableToArray = _unsupportedIterableToArray;

      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }

      var nonIterableRest = _nonIterableRest;

      function _slicedToArray(arr, i) {
        return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
      }

      var slicedToArray = _slicedToArray;

      dynamicLoader.register({
        test: /^@antv\/g6$/,
        path: function path() {
          return "./node_modules/@antv/g6/dist/g6.min.js";
        }
      });
      dynamicLoader.register({
        test: /^@antv\/hierarchy$/,
        path: function path() {
          return "./node_modules/@antv/hierarchy/dist/hierarchy.min.js";
        }
      });

      var mG6 = module.import('@antv/g6');
      var mHierarchy = module.import('@antv/hierarchy');

      function COLLAPSE_ICON(x, y, r) {
        return [['M', x, y], ['a', r, r, 0, 1, 0, r * 2, 0], ['a', r, r, 0, 1, 0, -r * 2, 0], ['M', x + 2, y], ['L', x + 2 * r - 2, y]];
      }

      function EXPAND_ICON(x, y, r) {
        return [['M', x, y], ['a', r, r, 0, 1, 0, r * 2, 0], ['a', r, r, 0, 1, 0, -r * 2, 0], ['M', x + 2, y], ['L', x + 2 * r - 2, y], ['M', x + r, y - r + 2], ['L', x + r, y + r - 2]];
      }

      var script = {
        props: {
          metaTitle: {
            type: String,
            "default": ''
          },
          metaOpts: {
            type: String,
            "default": ''
          }
        },
        mounted: function mounted() {
          var _this = this;

          Promise.all([mG6, mHierarchy]).then(function (modules) {
            var _modules = slicedToArray(modules, 2),
                G6 = _modules[0]["default"],
                Hierarchy = _modules[1]["default"];

            var n = 0;
            var options = qs.parse(_this.metaOpts);
            G6.registerNode('tree-node', {
              drawShape: function drawShape(cfg, group) {
                var rect = group.addShape('rect', {
                  attrs: {
                    fill: '#fff',
                    stroke: '#666'
                  }
                });
                var content = cfg.text && cfg.text.replace(/(.{19})/g, '$1\n') || '';
                var text = group.addShape('text', {
                  attrs: {
                    text: content,
                    x: 0,
                    y: 0,
                    textAlign: 'left',
                    textBaseline: 'middle',
                    fill: '#666'
                  }
                });
                var bbox = text.getBBox();
                var hasChildren = cfg.children && cfg.children.length;

                if (hasChildren) {
                  group.addShape('marker', {
                    attrs: {
                      x: bbox.maxX + 6,
                      y: bbox.minX + bbox.height / 2 - 6,
                      r: 6,
                      symbol: cfg.collapsed ? EXPAND_ICON : COLLAPSE_ICON,
                      stroke: '#666',
                      lineWidth: 2
                    },
                    className: 'collapse-icon'
                  });
                }

                rect.attr({
                  x: bbox.minX - 4,
                  y: bbox.minY - 6,
                  width: bbox.width + (hasChildren ? 26 : 8),
                  height: bbox.height + 12
                });
                return rect;
              }
            }, 'single-shape');
            var graph = new G6.TreeGraph({
              container: _this.$refs.graph,
              width: _this.$el.offsetWidth,
              height: parseInt(options.height) || 300,
              plugins: [],
              modes: {
                "default": [],
                explorer: [{
                  type: 'collapse-expand',
                  onChange: function onChange(item, collapsed) {
                    var data = item.getModel();
                    var icon = item.get('group').findByClassName('collapse-icon');

                    if (collapsed) {
                      icon.attr('symbol', EXPAND_ICON);
                    } else {
                      icon.attr('symbol', COLLAPSE_ICON);
                    }

                    data.collapsed = collapsed;
                    return true;
                  }
                }, 'drag-canvas', 'zoom-canvas']
              },
              defaultNode: {
                shape: 'tree-node',
                anchorPoints: [[0, 0.5], [1, 0.5]]
              },
              defaultEdge: {
                shape: 'cubic-horizontal'
              },
              edgeStyle: {
                "default": {
                  stroke: '#A3B1BF'
                }
              },
              layout: function layout(data) {
                return Hierarchy.compactBox(data, {
                  direction: options.direction || 'H',
                  getId: function getId(d) {
                    if (!d.id) {
                      d.id = "".concat(this._uid, "_").concat(n++);
                    }

                    return d.id;
                  },
                  getHeight: function getHeight() {
                    return 16;
                  },
                  getWidth: function getWidth() {
                    return 16;
                  },
                  getVGap: function getVGap() {
                    return 20;
                  },
                  getHGap: function getHGap() {
                    return 80;
                  }
                });
              }
            });
            _this.graph = graph;

            try {
              graph.data(jsonic(he.decode(_this.$refs.source.innerHTML)));
              graph.render();
              graph.fitView();
            } catch (e) {
              console.log('Draw mindmap error:', e);
            }
          });
        },
        methods: {
          onFocus: function onFocus() {
            if (this.graph) {
              this.graph.setMode('explorer');
            }
          },
          onBlur: function onBlur() {
            if (this.graph) {
              this.graph.setMode('default');
            }
          }
        }
      };

      function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
          if (typeof shadowMode !== 'boolean') {
              createInjectorSSR = createInjector;
              createInjector = shadowMode;
              shadowMode = false;
          }
          // Vue.extend constructor export interop.
          const options = typeof script === 'function' ? script.options : script;
          // render functions
          if (template && template.render) {
              options.render = template.render;
              options.staticRenderFns = template.staticRenderFns;
              options._compiled = true;
              // functional template
              if (isFunctionalTemplate) {
                  options.functional = true;
              }
          }
          // scopedId
          if (scopeId) {
              options._scopeId = scopeId;
          }
          let hook;
          if (moduleIdentifier) {
              // server build
              hook = function (context) {
                  // 2.3 injection
                  context =
                      context || // cached call
                          (this.$vnode && this.$vnode.ssrContext) || // stateful
                          (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
                  // 2.2 with runInNewContext: true
                  if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                      context = __VUE_SSR_CONTEXT__;
                  }
                  // inject component styles
                  if (style) {
                      style.call(this, createInjectorSSR(context));
                  }
                  // register component module identifier for async chunk inference
                  if (context && context._registeredComponents) {
                      context._registeredComponents.add(moduleIdentifier);
                  }
              };
              // used by ssr in case component is cached and beforeCreate
              // never gets called
              options._ssrRegister = hook;
          }
          else if (style) {
              hook = shadowMode
                  ? function (context) {
                      style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
                  }
                  : function (context) {
                      style.call(this, createInjector(context));
                  };
          }
          if (hook) {
              if (options.functional) {
                  // register for functional component in vue file
                  const originalRender = options.render;
                  options.render = function renderWithStyleInjection(h, context) {
                      hook.call(context);
                      return originalRender(h, context);
                  };
              }
              else {
                  // inject component registration as beforeCreate hook
                  const existing = options.beforeCreate;
                  options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
              }
          }
          return script;
      }

      const isOldIE = typeof navigator !== 'undefined' &&
          /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
      function createInjector(context) {
          return (id, style) => addStyle(id, style);
      }
      let HEAD;
      const styles = {};
      function addStyle(id, css) {
          const group = isOldIE ? css.media || 'default' : id;
          const style = styles[group] || (styles[group] = { ids: new Set(), styles: [] });
          if (!style.ids.has(id)) {
              style.ids.add(id);
              let code = css.source;
              if (css.map) {
                  // https://developer.chrome.com/devtools/docs/javascript-debugging
                  // this makes source maps inside style tags work properly in Chrome
                  code += '\n/*# sourceURL=' + css.map.sources[0] + ' */';
                  // http://stackoverflow.com/a/26603875
                  code +=
                      '\n/*# sourceMappingURL=data:application/json;base64,' +
                          btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) +
                          ' */';
              }
              if (!style.element) {
                  style.element = document.createElement('style');
                  style.element.type = 'text/css';
                  if (css.media)
                      style.element.setAttribute('media', css.media);
                  if (HEAD === undefined) {
                      HEAD = document.head || document.getElementsByTagName('head')[0];
                  }
                  HEAD.appendChild(style.element);
              }
              if ('styleSheet' in style.element) {
                  style.styles.push(code);
                  style.element.styleSheet.cssText = style.styles
                      .filter(Boolean)
                      .join('\n');
              }
              else {
                  const index = style.ids.size - 1;
                  const textNode = document.createTextNode(code);
                  const nodes = style.element.childNodes;
                  if (nodes[index])
                      style.element.removeChild(nodes[index]);
                  if (nodes.length)
                      style.element.insertBefore(textNode, nodes[index]);
                  else
                      style.element.appendChild(textNode);
              }
          }
      }

      /* script */
      var __vue_script__ = script;
      /* template */

      var __vue_render__ = function __vue_render__() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c("BTabs", {
          attrs: {
            small: "",
            card: ""
          }
        }, [_c("BTab", {
          attrs: {
            title: "Graph",
            active: ""
          }
        }, [_c("div", {
          ref: "graph",
          staticClass: "g6-mindmap",
          staticStyle: {
            "outline-width": "thin"
          },
          attrs: {
            tabindex: "1000"
          },
          on: {
            focus: _vm.onFocus,
            blur: _vm.onBlur
          }
        })]), _vm._v(" "), _c("BTab", {
          attrs: {
            title: "Source"
          }
        }, [_c("pre", {
          ref: "source"
        }, [_vm._t("default")], 2)])], 1);
      };

      var __vue_staticRenderFns__ = [];
      __vue_render__._withStripped = true;
      /* style */

      var __vue_inject_styles__ = function __vue_inject_styles__(inject) {
        if (!inject) return;
        inject("data-v-566f3ec8_0", {
          source: "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
          map: {
            "version": 3,
            "sources": [],
            "names": [],
            "mappings": "",
            "file": "index.vue"
          },
          media: undefined
        });
      };
      /* scoped */


      var __vue_scope_id__ = undefined;
      /* module identifier */

      var __vue_module_identifier__ = undefined;
      /* functional template */

      var __vue_is_functional_template__ = false;
      /* style inject SSR */

      /* style inject shadow dom */

      var __vue_component__ = exports('default', /*#__PURE__*/normalizeComponent({
        render: __vue_render__,
        staticRenderFns: __vue_staticRenderFns__
      }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, createInjector, undefined, undefined));

    }
  };
});
