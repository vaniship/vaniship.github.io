/**
* @mdblog/code-plugin-mindmap v2.0.1
* Copyright Â© mdblog 2019.
*/

System.register(['@mdblog/mdblog', 'he', 'jsonic', 'qs'], function (exports, module) {
  'use strict';
  var dynamicLoader, he, jsonic, qs;
  return {
    setters: [function (module) {
      dynamicLoader = module.dynamicLoader;
    }, function (module) {
      he = module.default;
    }, function (module) {
      jsonic = module.default;
    }, function (module) {
      qs = module.default;
    }],
    execute: function () {

      function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
      }

      var arrayWithHoles = _arrayWithHoles;

      function _iterableToArrayLimit(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = undefined;

        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);

            if (i && _arr.length === i) break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"] != null) _i["return"]();
          } finally {
            if (_d) throw _e;
          }
        }

        return _arr;
      }

      var iterableToArrayLimit = _iterableToArrayLimit;

      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }

      var nonIterableRest = _nonIterableRest;

      function _slicedToArray(arr, i) {
        return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
      }

      var slicedToArray = _slicedToArray;

      dynamicLoader.register({
        test: /^@antv\/g6$/,
        path: function path() {
          return "./node_modules/@antv/g6/build/g6.js";
        }
      });
      dynamicLoader.register({
        test: /^@antv\/hierarchy$/,
        path: function path() {
          return "./node_modules/@antv/hierarchy/build/hierarchy.js";
        }
      });

      var mG6 = module.import('@antv/g6');
      var mHierarchy = module.import('@antv/hierarchy');

      function COLLAPSE_ICON(x, y, r) {
        return [['M', x, y], ['a', r, r, 0, 1, 0, r * 2, 0], ['a', r, r, 0, 1, 0, -r * 2, 0], ['M', x + 2, y], ['L', x + 2 * r - 2, y]];
      }

      function EXPAND_ICON(x, y, r) {
        return [['M', x, y], ['a', r, r, 0, 1, 0, r * 2, 0], ['a', r, r, 0, 1, 0, -r * 2, 0], ['M', x + 2, y], ['L', x + 2 * r - 2, y], ['M', x + r, y - r + 2], ['L', x + r, y + r - 2]];
      }

      var script = {
        props: {
          metaTitle: {
            type: String,
            "default": ''
          },
          metaOpts: {
            type: String,
            "default": ''
          }
        },
        mounted: function mounted() {
          var _this = this;

          Promise.all([mG6, mHierarchy]).then(function (modules) {
            var _modules = slicedToArray(modules, 2),
                G6 = _modules[0]["default"],
                Hierarchy = _modules[1]["default"];

            var n = 0;
            var options = qs.parse(_this.metaOpts);
            G6.registerNode('tree-node', {
              drawShape: function drawShape(cfg, group) {
                var rect = group.addShape('rect', {
                  attrs: {
                    fill: '#fff',
                    stroke: '#666'
                  }
                });
                var content = cfg.text && cfg.text.replace(/(.{19})/g, '$1\n') || '';
                var text = group.addShape('text', {
                  attrs: {
                    text: content,
                    x: 0,
                    y: 0,
                    textAlign: 'left',
                    textBaseline: 'middle',
                    fill: '#666'
                  }
                });
                var bbox = text.getBBox();
                var hasChildren = cfg.children && cfg.children.length;

                if (hasChildren) {
                  group.addShape('marker', {
                    attrs: {
                      x: bbox.maxX + 6,
                      y: bbox.minX + bbox.height / 2 - 6,
                      r: 6,
                      symbol: cfg.collapsed ? EXPAND_ICON : COLLAPSE_ICON,
                      stroke: '#666',
                      lineWidth: 2
                    },
                    className: 'collapse-icon'
                  });
                }

                rect.attr({
                  x: bbox.minX - 4,
                  y: bbox.minY - 6,
                  width: bbox.width + (hasChildren ? 26 : 8),
                  height: bbox.height + 12
                });
                return rect;
              }
            }, 'single-shape');
            var graph = new G6.TreeGraph({
              container: _this.$refs.graph,
              width: _this.$el.offsetWidth,
              height: parseInt(options.height) || 300,
              plugins: [],
              modes: {
                "default": [{
                  type: 'collapse-expand',
                  onChange: function onChange(item, collapsed) {
                    var data = item.getModel();
                    var icon = item.get('group').findByClassName('collapse-icon');

                    if (collapsed) {
                      icon.attr('symbol', EXPAND_ICON);
                    } else {
                      icon.attr('symbol', COLLAPSE_ICON);
                    }

                    data.collapsed = collapsed;
                    return true;
                  }
                }, 'drag-canvas', 'zoom-canvas']
              },
              defaultNode: {
                shape: 'tree-node',
                anchorPoints: [[0, 0.5], [1, 0.5]]
              },
              defaultEdge: {
                shape: 'cubic-horizontal'
              },
              edgeStyle: {
                "default": {
                  stroke: '#A3B1BF'
                }
              },
              layout: function layout(data) {
                return Hierarchy.compactBox(data, {
                  direction: options.direction || 'H',
                  getId: function getId(d) {
                    if (!d.id) {
                      d.id = "".concat(this._uid, "_").concat(n++);
                    }

                    return d.id;
                  },
                  getHeight: function getHeight() {
                    return 16;
                  },
                  getWidth: function getWidth() {
                    return 16;
                  },
                  getVGap: function getVGap() {
                    return 20;
                  },
                  getHGap: function getHGap() {
                    return 80;
                  }
                });
              }
            });

            try {
              graph.data(jsonic(he.decode(_this.$refs.source.innerHTML)));
              graph.render();
              graph.fitView();
            } catch (e) {
              console.log('Draw mindmap error:', e);
            }
          });
        }
      };

      function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier
      /* server only */
      , shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
        if (typeof shadowMode !== 'boolean') {
          createInjectorSSR = createInjector;
          createInjector = shadowMode;
          shadowMode = false;
        } // Vue.extend constructor export interop.


        var options = typeof script === 'function' ? script.options : script; // render functions

        if (template && template.render) {
          options.render = template.render;
          options.staticRenderFns = template.staticRenderFns;
          options._compiled = true; // functional template

          if (isFunctionalTemplate) {
            options.functional = true;
          }
        } // scopedId


        if (scopeId) {
          options._scopeId = scopeId;
        }

        var hook;

        if (moduleIdentifier) {
          // server build
          hook = function hook(context) {
            // 2.3 injection
            context = context || // cached call
            this.$vnode && this.$vnode.ssrContext || // stateful
            this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
            // 2.2 with runInNewContext: true

            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
              context = __VUE_SSR_CONTEXT__;
            } // inject component styles


            if (style) {
              style.call(this, createInjectorSSR(context));
            } // register component module identifier for async chunk inference


            if (context && context._registeredComponents) {
              context._registeredComponents.add(moduleIdentifier);
            }
          }; // used by ssr in case component is cached and beforeCreate
          // never gets called


          options._ssrRegister = hook;
        } else if (style) {
          hook = shadowMode ? function () {
            style.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
          } : function (context) {
            style.call(this, createInjector(context));
          };
        }

        if (hook) {
          if (options.functional) {
            // register for functional component in vue file
            var originalRender = options.render;

            options.render = function renderWithStyleInjection(h, context) {
              hook.call(context);
              return originalRender(h, context);
            };
          } else {
            // inject component registration as beforeCreate hook
            var existing = options.beforeCreate;
            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
          }
        }

        return script;
      }

      var normalizeComponent_1 = normalizeComponent;

      var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
      function createInjector(context) {
        return function (id, style) {
          return addStyle(id, style);
        };
      }
      var HEAD = document.head || document.getElementsByTagName('head')[0];
      var styles = {};

      function addStyle(id, css) {
        var group = isOldIE ? css.media || 'default' : id;
        var style = styles[group] || (styles[group] = {
          ids: new Set(),
          styles: []
        });

        if (!style.ids.has(id)) {
          style.ids.add(id);
          var code = css.source;

          if (css.map) {
            // https://developer.chrome.com/devtools/docs/javascript-debugging
            // this makes source maps inside style tags work properly in Chrome
            code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

            code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
          }

          if (!style.element) {
            style.element = document.createElement('style');
            style.element.type = 'text/css';
            if (css.media) style.element.setAttribute('media', css.media);
            HEAD.appendChild(style.element);
          }

          if ('styleSheet' in style.element) {
            style.styles.push(code);
            style.element.styleSheet.cssText = style.styles.filter(Boolean).join('\n');
          } else {
            var index = style.ids.size - 1;
            var textNode = document.createTextNode(code);
            var nodes = style.element.childNodes;
            if (nodes[index]) style.element.removeChild(nodes[index]);
            if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
          }
        }
      }

      var browser = createInjector;

      /* script */
      var __vue_script__ = script;
      /* template */

      var __vue_render__ = function __vue_render__() {
        var _vm = this;

        var _h = _vm.$createElement;

        var _c = _vm._self._c || _h;

        return _c("BTabs", {
          attrs: {
            small: "",
            card: ""
          }
        }, [_c("BTab", {
          attrs: {
            title: "Graph",
            active: ""
          }
        }, [_c("div", {
          ref: "graph",
          staticClass: "g6-mindmap"
        })]), _vm._v(" "), _c("BTab", {
          attrs: {
            title: "Source"
          }
        }, [_c("pre", {
          ref: "source"
        }, [_vm._t("default")], 2)])], 1);
      };

      var __vue_staticRenderFns__ = [];
      __vue_render__._withStripped = true;
      /* style */

      var __vue_inject_styles__ = function __vue_inject_styles__(inject) {
        if (!inject) return;
        inject("data-v-44e3957c_0", {
          source: "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
          map: {
            "version": 3,
            "sources": [],
            "names": [],
            "mappings": "",
            "file": "index.vue"
          },
          media: undefined
        });
      };
      /* scoped */


      var __vue_scope_id__ = undefined;
      /* module identifier */

      var __vue_module_identifier__ = undefined;
      /* functional template */

      var __vue_is_functional_template__ = false;
      /* style inject SSR */

      var index = exports('default', normalizeComponent_1({
        render: __vue_render__,
        staticRenderFns: __vue_staticRenderFns__
      }, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, browser, undefined));

    }
  };
});
